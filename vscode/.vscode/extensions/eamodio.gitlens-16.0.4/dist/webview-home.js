exports.id=928,exports.ids=[928],exports.modules={2465:(e,t,i)=>{i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var s=i(1398),o=i(1683),n=i(2496),r=i(5546),a=i(281),h=i(5309),l=i(6348),d=i(9145),c=i(5289),u=i(3788),p=i(8255),g=i(8381),v=i(5868),w=i(216),m=i(9104);async function b(e){let t=await e.launchpad.getCategorizedItems(),i=w.H.get("launchpad.indicator.groups")??[];return(0,m.a)(t.items,i)}var f=i(2623),y=i(6275),C=i(9153),R=i(2414),S=i(5395),_=i(8757),P=i(7279),D=i(444);let k="home",O=new D.Oz(k,"launchpad/summary"),B=new D.Oz(k,"overview"),I=new D.Oz(k,"overviewFilter"),T=new D.Oz(k,"overview/repository/change"),q=new D.Q2(k,"previewEnabled/toggle"),W=new D.Q2(k,"section/collapse"),A=new D.Q2(k,"walkthrough/dismiss"),L=new D.Q2(k,"overview/filter/set"),z=new D.Q2(k,"openInGraph"),F=new D.C1(k,"repositories/didCompleteDiscovering"),$=new D.C1(k,"previewEnabled/didChange"),E=new D.C1(k,"repository/wip/didChange"),x=new D.C1(k,"repositories/didChange"),H=new D.C1(k,"walkthroughProgress/didChange"),M=new D.C1(k,"integrations/didChange"),Z=new D.C1(k,"subscription/didChange"),U=new D.C1(k,"org/settings/didChange"),G=new D.C1(k,"home/ownerFilter/didChange"),N=new D.C1(k,"account/didFocus"),Q=Object.freeze({dispose:()=>{}});let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=s.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),s.workspace.isTrusted?Q:s.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,_.wt)(this.onContextChanged,this),this.container.integrations.onDidChangeConnectionState(this.onChangeConnectionState,this),this.container.walkthrough.onProgressChanged(this.onWalkthroughChanged,this),w.H.onDidChange(this.onDidChangeConfig,this))}_disposable;_discovering;_etag;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[s]=i;if(s?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(N,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._etag=await this._discovering,this._discovering=void 0,this.notifyDidCompleteDiscoveringRepositories())}onChangeConnectionState(){this.notifyDidChangeOnboardingIntegration()}async shouldNotifyRepositoryChange(){return this._etag!==this.container.git.etag&&(null==this._discovering||(this._etag=await this._discovering,this._etag!==this.container.git.etag))}async onChooseRepository(){let e=this.getSelectedRepository(),t=this.container.git.openRepositories.sort((t,i)=>(t===e?1:-1)-(i===e?1:-1)||(t.starred?-1:1)-(i.starred?-1:1)||t.index-i.index),i=await (0,f.oe)(`Switch Repository ${n.EO.Dot} ${e?.name}`,"Choose a repository to switch to",t);null!=i&&i!==e&&this.selectRepository(i.path)}async onRepositoriesChanged(){await this.shouldNotifyRepositoryChange()&&this.notifyDidChangeRepositories()}onWalkthroughChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){w.H.changed(e,"home.preview.enabled")&&this.notifyDidChangeConfig()}async push(e=!1){let t=this.getSelectedRepository();return t?(0,a.b)({command:"push",state:{repos:[t],flags:e?["--force"]:void 0}}):Promise.resolve()}async pull(){let e=this.getSelectedRepository();return e?(0,a.b)({command:"pull",state:{repos:[e]}}):Promise.resolve()}registerCommands(){return[(0,S.Lb)(`${this.host.id}.pull`,this.pull,this),(0,S.Lb)(`${this.host.id}.push`,e=>{this.push(e.force)},this),(0,S.Lb)(`${this.host.id}.publishBranch`,this.push,this),(0,S.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,S.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,S.Lb)(`${this.host.id}.previewFeedback`,()=>(0,P.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,S.Lb)(`${this.host.id}.whatsNew`,()=>(0,P.CZ)(n.DS.releaseNotes),this),(0,S.Lb)(`${this.host.id}.help`,()=>(0,P.CZ)(n.DS.helpCenter),this),(0,S.Lb)(`${this.host.id}.issues`,()=>(0,P.CZ)(n.DS.githubIssues),this),(0,S.Lb)(`${this.host.id}.discussions`,()=>(0,P.CZ)(n.DS.githubDiscussions),this),(0,S.Lb)(`${this.host.id}.account.resync`,()=>this.container.subscription.validate({force:!0}),this),(0,S.Lb)("gitlens.home.openPullRequestChanges",this.pullRequestChanges,this),(0,S.Lb)("gitlens.home.openPullRequestComparison",this.pullRequestCompare,this),(0,S.Lb)("gitlens.home.openPullRequestOnRemote",this.pullRequestViewOnRemote,this),(0,S.Lb)("gitlens.home.createPullRequest",this.pullRequestCreate,this),(0,S.Lb)("gitlens.home.openWorktree",this.worktreeOpen,this),(0,S.Lb)("gitlens.home.switchToBranch",this.switchToBranch,this),(0,S.Lb)("gitlens.home.fetch",this.fetch,this),(0,S.Lb)("gitlens.home.openInGraph",this.openInGraph,this)]}setOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(G,{filter:this._overviewBranchFilter})}async onMessageReceived(e){switch(!0){case W.is(e):this.onCollapseSection(e.params);break;case A.is(e):this.dismissWalkthrough();break;case L.is(e):this.setOverviewFilter(e.params);break;case O.is(e):this.host.respond(O,e,await b(this.container));break;case B.is(e):this.host.respond(B,e,await this.getBranchOverview());break;case I.is(e):this.host.respond(I,e,this._overviewBranchFilter);break;case T.is(e):await this.onChooseRepository(),this.host.respond(T,e,void 0);break;case q.is(e):this.onTogglePreviewEnabled();break;case z.is(e):this.openInGraph(e.params)}}includeBootstrap(){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(N,void 0))}onVisibilityChanged(e){if(!e){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(),this.notifyDidChangeRepositories(!0)}openInGraph(e){let t;if(e?.type==="branch"){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=(0,u.iw)(i);if(null==s)return;(0,S.RS)(r.T.ShowInCommitGraph,{ref:s});return}if(null==e)t=this.getSelectedRepository();else{let i=this._repositoryBranches.get(e.repoPath);t=i?.repo}null!=t&&(0,S.RS)(r.T.ShowGraph,t)}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),w.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]);return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]);return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t))}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0),this.container.usage.track("home:walkthrough:dismissed"))}getWalkthroughDismissed(){return!!this.container.storage.get("home:walkthrough:dismissed")}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}getOrgSettings(){return{drafts:(0,_.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onContextChanged(e){"gitlens:gk:organization:drafts:enabled"===e&&this.notifyDidChangeOrgSettings()}onSubscriptionChanged(e){this.notifyDidChangeSubscription(e.current)}async getState(e){let t=await this.getSubscription(e);return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount,orgSettings:this.getOrgSettings(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),hasAnyIntegrationConnected:this.isAnyIntegrationConnected(),walkthroughProgress:{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress},showWalkthroughProgress:!this.getWalkthroughDismissed(),previewEnabled:this.getPreviewEnabled(),newInstall:(0,_.SD)("gitlens:install:new",!1)}}getPreviewEnabled(){return w.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:s.workspace.isTrusted}}async getBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i=void 0!==this._invalidateOverview,s=await this.getBranchesData(e,t),o=await V(s,this.container,this._overviewBranchFilter,i?{forceActive:!0}:void 0);if(this._invalidateOverview=void 0,null!=o)return{repository:{...await this.formatRepository(e),branches:o}}}async formatRepository(e){let t=await e.git.getBestRemotesWithProviders(),i=t.find(e=>e.hasIntegration())??t[0];return{name:e.commonRepositoryName??e.name,path:e.path,provider:i?.provider?{name:i.provider.name,icon:"remote"===i.provider.icon?"cloud":i.provider.icon,url:i.provider.url({type:p.J.Repo})}:void 0}}_repositorySubscription;selectRepository(e){let t;return null!=e?t=this.container.git.getRepository(e):null==(t=this.container.git.highlander)&&(t=this.container.git.getBestRepositoryOrFirst()),null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription=void 0),null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepository(t)}),t}stopRepositorySubscription(){null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0)}resumeRepositorySubscription(e=!1){null!=this._repositorySubscription&&(e||null==this._repositorySubscription.subscription)&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0,this._repositorySubscription.subscription=this.subscribeToRepository(this._repositorySubscription.repo))}resetBranchOverview(){if(this._repositoryBranches.clear(),!this.host.visible){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(!0)}subscribeToRepository(e){return s.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(()=>this.onOverviewRepoChanged("wip")),e.onDidChange(e=>{e.changed(g.Z_.Unknown,g.Z_.Index,g.Z_.Status,g.Z_.Remotes,g.Z_.Config,g.Z_.Heads,g.Ti.Any)&&this.onOverviewRepoChanged("repo")}))}onOverviewRepoChanged(e){"repo"!==this._invalidateOverview&&(this._invalidateOverview=e),this.host.visible&&("wip"===e?this.host.notify(E,void 0):this.notifyDidChangeRepositories())}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.repo}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)){let t=await e.git.getWorktrees()??[],i=(0,v.PU)(t,{includeDefault:!0}),[s]=await Promise.allSettled([e.git.getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,v.vJ)(i)}})]),o=R.Ro(s)?.values??[];this._repositoryBranches.set(e.path,{repo:e,branches:o,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_hostedIntegrationConnected;isAnyIntegrationConnected(e=!1){return(null==this._hostedIntegrationConnected||!0===e)&&(this._hostedIntegrationConnected=[...this.container.integrations.getConnected("hosting"),...this.container.integrations.getConnected("issues")].length>0),this._hostedIntegrationConnected}async getSubscription(e){let t;return e??=await this.container.subscription.getSubscription(!0),t=e.account?.email?(0,o.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(F,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(x,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(e){this.notifyDidChangeRepositoriesCore();return}null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,y.sg)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}notifyDidChangeProgress(){this.host.notify(H,{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress})}notifyDidChangeConfig(){this.host.notify($,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed()})}notifyDidChangeOnboardingIntegration(){let e=this.isAnyIntegrationConnected(!0);e&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(M,{hasAnyIntegrationConnected:e})}async notifyDidChangeSubscription(e){let t=await this.getSubscription(e);this.host.notify(Z,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(U,{orgSettings:this.getOrgSettings()})}async pullRequestCompare(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,c.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,c.tI)(e.repoPath,t.refs);return(0,h.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestViewOnRemote(e,t){let i=await this.findPullRequest(e);null!=i&&(0,S.RS)(r.T.OpenPullRequestOnRemote,{pr:{url:i.url},clipboard:t})}async pullRequestCreate(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=await i.getRemote();null!=s&&(0,S.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=s?{name:s.name,provider:null!=s.provider?{id:s.provider.id,name:s.provider.name,domain:s.provider.domain}:void 0,url:s.url}:void 0,branch:{name:i.name,upstream:i.upstream?.name,isRemote:i.remote}})}worktreeOpen(e){let t=this.findWorktree(e);null!=t&&(0,P.OH)(t.uri)}switchToBranch(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);null!=i&&l.S_(t.repo,(0,u.iw)(i))}fetch(e){if(null==e){let e=this.getSelectedRepository();l.hd(e);return}let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);null!=i&&l.hd(t.repo,(0,u.iw)(i))}findBranch(e){let t=this._repositoryBranches.get(e.repoPath)?.branches;return t?.find(t=>t.id===e.branchId)}findWorktree(e){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return t.worktreesByBranch.get(i.id)}async findPullRequest(e){let t=this.findBranch(e);if(null!=t)return t.getAssociatedPullRequest()}};let j={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6};async function V(e,t,i,s){let o;let{branches:n,worktreesByBranch:r}=e;if(0===n.length)return;let a={active:[],recent:[],stale:[]},h=new Map,l=new Map,c=new Map,u=Date.now(),p=u-j[i.recent.threshold];for(let e of n){let i=r.get(e.id),n=i?{name:i.name,uri:i.uri.toString()}:void 0,d=e.date?.getTime();if(e.current||i?.opened){let r=s?.forceActive?{force:!0}:void 0;h.set(e.id,e.getAssociatedPullRequest({avatarSize:16})),null!=i?l.set(e.id,i.getStatus(r)):(void 0===o&&(o=t.git.getStatus(e.repoPath)),l.set(e.id,o)),c.set(e.id,t.git.getBranchContributorOverview(e.repoPath,e.ref)),a.active.push({id:e.id,name:e.name,opened:!0,timestamp:d,state:e.state,status:e.status,upstream:e.upstream,worktree:n});continue}if(null!=d&&d>p){h.set(e.id,e.getAssociatedPullRequest()),null!=i&&l.set(e.id,i.getStatus()),c.set(e.id,t.git.getBranchContributorOverview(e.repoPath,e.ref)),a.recent.push({id:e.id,name:e.name,opened:!1,timestamp:d,state:e.state,status:e.status,upstream:e.upstream,worktree:n});continue}}if(i?.stale?.show===!0){let e=u-j[i.stale.threshold];for(let i of((0,d.Xn)(n,{missingUpstream:!0,orderBy:"date:asc"}),n)){if(a.stale.length>9)break;if(a.active.some(e=>e.id===i.id)||a.recent.some(e=>e.id===i.id))continue;let s=i.date?.getTime();if(i.upstream?.missing||null!=s&&s<e){let e=r.get(i.id),o=e?{name:e.name,uri:e.uri.toString()}:void 0;i.upstream?.missing||h.set(i.id,i.getAssociatedPullRequest()),null!=e&&l.set(i.id,e.getStatus()),c.set(i.id,t.git.getBranchContributorOverview(i.repoPath,i.ref)),a.stale.push({id:i.id,name:i.name,opened:!1,timestamp:s,state:i.state,status:i.status,upstream:i.upstream,worktree:o});continue}}}return await J(a,h,l,c),a}async function J(e,t,i,s){let[o,n,r]=await Promise.allSettled([Promise.allSettled((0,C.Tj)(t,([e,t])=>t.then(t=>[e,t]))),Promise.allSettled((0,C.Tj)(i,([e,t])=>t.then(t=>[e,t]))),Promise.allSettled((0,C.Tj)(s,([e,t])=>t.then(t=>[e,t])))]),a=new Map(R.Ro(o)?.filter(e=>"fulfilled"===e.status).map(({value:[e,t]})=>[e,t?{id:t.id,title:t.title,state:t.state,url:t.url}:void 0])),h=new Map(R.Ro(n)?.filter(e=>"fulfilled"===e.status).map(e=>[e.value[0],e.value[1]])),l=new Map(R.Ro(r)?.filter(e=>"fulfilled"===e.status).map(e=>[e.value[0],e.value[1]]));for(let t of[...e.active,...e.recent,...e.stale]){let e=a.get(t.id);t.pr=e;let i=h.get(t.id);null!=i&&(t.workingTreeState=i.getDiffStatus());let s=l.get(t.id);if(null!=s){let e=null!=s.contributors?[...s.contributors]:void 0,i=s.owner??e?.shift();null!=i&&(t.owner={name:i.name??"",email:i.email??"",current:i.current,timestamp:i.date?.getTime(),count:i.count,stats:i.stats,avatarUrl:(await i.getAvatarUri())?.toString()});let o=e?await Promise.all(e.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.date?.getTime(),count:e.count,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()}))):void 0;t.contributors=o}}}}};